# 이선근 2주차 (12, 13 장)

# 12. 함수

입력을 받아 출력을 내보내는 과정.

일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

이렇게 함으로써 재사용성과 가독성을 높이는 효과를 얻을 수 있다.

![Untitled](https://snkn.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fb2262b-2219-432d-87b6-fbfb7bdda6ed%2F29308511-f350-4d26-a9b5-d7a5a290d802%2FUntitled.png?table=block&id=4d67be78-770a-42f0-a56f-3cfacdc5ab18&spaceId=9fb2262b-2219-432d-87b6-fbfb7bdda6ed&width=880&userId=&cache=v2)

함수를 사용하면 중복된 로직을 한 번만 작성해 여러 번 호출할 수 있어 **재사용성과 가독성**을 높일 수 있다.

## 함수 선언문과 함수 표현식

**함수의 정의 방법**

1. 함수 선언문
2. 함수 표현식
3. Function 생성자 함수
4. 화살표 함수 (ES6)

**변수 선언과 함수 정의 차이**

함수 선언문은 **표현식이 아닌 문**이다.

```jsx
// 함수 선언문. 함수 이름 생략 불가
function foo() {
  console.log('foo');
}

// 함수 표현식. 함수 리터럴을 변수에 할당
const bar = function foo() {
  console.log('foo');
};
```

함수 선언문은 표현식이 아닌 문인데 어떻게 변수에 할당 할 수 있을까?

→ JS엔진이 문맥에 따라 표현식과 표현식이 아닌 문으로 해석하는 경우가 있다. 함수가 단독으로 사용되느냐, 피연산자로 사용되느냐의 차이.

생성은 동일하나 내부 동작에서 차이가 있다.

함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

선언문으로 만들면 **함수 이름과 동일한 식별자를 암묵적으로 생성한다. 따라서 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.**

함수는 일급 객체라 변수에 할당할 수 있는데 이것이 함수 표현식이다.

일급 객체 = 값의 성질을 갖는 객체

- 변수에 할당 할 수 있고 프로퍼티 값이 될 수 있고 배열의 요소가 될 수도 있다.

**함수 생성 시점**

- 함수 선언문: 런타임 이전에 함수 객체가 먼저 생성된다. 이 때 함수 이름과 동일한 식별자를 암묵적으로 생성해 함수 객체를 할당한다.
  선언문 이전에 참조, 호출 가능 (함수 호이스팅)
- 함수 표현식: 변수와 동일하게 동작한다. 런타임 이전에 undefined로 초기화되지만 값은 런타임에 평가되어 함수 객체가 된다.

⇒ 함수 표현식은 함수 호이스팅이 아니라 변수 호이스팅이 발생

**Function 생성자 함수**

```jsx
let add = (() => {
  let a = 10;
  return new Function('x', 'y', 'return x + y + a');
})();

console.log(add(1, 2)); // ReferenceError: a is not defined
```

클로저를 생성하지 않는 등 동작이 달라 사용 권장 X

**화살표 함수**

표현만 간략한 것이 아니라 내부 동작도 간략화되어 있다.

- this 바인딩 방식이 다름
- prototype 프로퍼티가 없으며 arguments 객체 생성 X

## 매개변수, 인수

매개변수: 함수 외부에서 내부로 전달할 변수

함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다.

매개변수보다 인수가 많은 경우 초과된 인수는 무시된다.

arguments 객체: 매개변수를 확정할 수 없는 가변 인자 함수를 구현할 때 사용

```jsx
function add2(x, y) {
  console.log(arguments); // { '0': 1, '1': 2, '2': 3 }
  return x + y;
}

add2(1, 2, 3);
```

<aside>
💡 이상적인 매개변수의 개수
명시적으로 제한하지 않으나, 최대 3개 이상을 넘지 않는 것을 권장한다. 그 이상의 매개변수가 필요하다면 하나의 객체로 전달하는 것이 유리하다.
**이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.**

</aside>

## 참조에 의한 호출

인수로 원시 타입과 객체 타입을 전달 했을 때의 차이

- 원시 타입을 전달했을 때: 직접 변경할 수 없기 때문에 재할당을 통해 할당된 원시 값을 새로운 원시 값으로 교체
- 객체 타입을 전달했을 때: 참조 값이 복사되어 전달되기 때문에 객체 변경시 원본이 훼손된다 (부수 효과 발생)
  객체를 복사해 새로운 객체를 생성해 순수 함수로 만들어서 사용하자!

### 순수 함수

어떤 외부 상태에 의존하지도 않고 변경하지도 않는(부수 효과가 없는) 함수.

순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다.

---

# 13. 스코프

```jsx
function add(x, y) {
  console.log(x, y);
  return x + y;
}

add(2, 5);

console.log(x, y);
```

식별자를 참조할 수 있는 유효 범위. 자신이 선언된 위치에 의해 결정된다.

```jsx
var x = 'global';

function foo() {
  var x = 'local';
  ****console.log(x);
}

foo();

console.log(x);
```

바깥의 x는 어디서든 참조할 수 있지만, foo 내부의 x는 foo 함수 내에서만 참조할 수 있다.

식별자 이름 x는 동일하지만 스코프가 다른 별개의 변수다.

스코프가 없다면 같은 이름을 갖는 변수는 프로그램 전체에서 하나밖에 사용할 수 없다.

<aside>
💡 네임스페이스

하나의 네임스페이스에서는 하나의 이름이 단 하나의 개체만을 가리킨다.

즉 스코프는 네임스페이스다.

</aside>

var는 같은 스코프 내에서 중복 선언이 된다.

```jsx
let x = 1;
let x = 2; // SyntaxError: Identifier 'x' has already been declared

var x = 1;
var x = 2;
```

## 전역 스코프와 지역 스코프

**전역 스코프**

- 전역 = 코드의 가장 바깥 영역
- 전역에서 변수를 선언하면 전역 변수가 된다.
- 전역변수는 어디서든지 참조할 수 있다.

**지역 스코프**

지역 = 함수 몸체 내부

지역에서 변수를 선언하면 지역 변수가 된다.

지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서만 참조할 수 있다.

**var**는 함수의 코드 블록만을 지역 스코프로 인정하는 **함수 레벨 스코프**지만,

**let, const**는 if, for, try/catch 같은 모든 코드 블록을 지역 스코프로 인정하는 **블록 레벨 스코프**이다.

## 스코프 체인

변수를 참조할 때 현재 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.

때문에 하위 스코프에서는 상위 스코프의 변수를 참조할 수 있지만, 상위 스코프에서는 하위 스코프의 변수를 참조할 수 없다.

```jsx
let x = 'global x';
let y = 'global y';

function outer() {
  let z = "outer's local z";

  console.log(x);
  console.log(y);
  console.log(z);

  function inner() {
    let x = "inner's local x";

    console.log(x);
    console.log(y);
    console.log(z);
  }

  inner();
}

outer();

console.log(x);
```

![Untitled](https://snkn.notion.site/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F9fb2262b-2219-432d-87b6-fbfb7bdda6ed%2F0b164267-8182-42c4-934a-7d90498d6bff%2FUntitled.png?table=block&id=9f4458f3-b2a1-4999-89ea-2d673720442c&spaceId=9fb2262b-2219-432d-87b6-fbfb7bdda6ed&width=770&userId=&cache=v2)

## 렉시컬 스코프

```jsx
let x = 1;

function foo() {
  let x = 'local';
  bar();
}

function bar() {
  console.log(x);
}

foo();
bar();
```

자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

동적 스코프: **함수를 어디서 호출**했는지에 따라 상위 스코프를 결정

렉시컬 스코프(정적 스코프): **함수를 어디서 정의**했는지에 따라 함수의 상위 스코프를 결정
