# 이선근 1주차 (7, 8, 9 장)

## 7. 연산자

**연산자**: 하나 이상의 표현식을 대상으로 산술, 비교, 논리 등을 수행해 하나의 값을 만든다. 이 때 연산의 대상을 **피연산자**라고 하며 피연산자는 표현식이어야 한다.

### 산술 연산자

수학적 계산을 수행해 새로운 값을 만드는 연산자.

피연산자가 2개인 **이항 산술 연산자**와 1개인 **단항 산술 연산자**가 있다.

**부수 효과**(side effect): 연산이 외부 상태에 영향을 미치는 것.

- 부수 효과가 있는 연산자: ++, --
  - 할당 연산자

피연산자 중 문자열이 포함되어있다면 + 연산자는 **문자열 연결 연산자**로 동작한다.

### 할당 연산자

할당 연산자는 우항의 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

할당문도 표현식이다!

### 비교 연산자

비교 연산자는 좌항과 우항의 피연산자를 비교하여 그 결과를 불리언 값으로 반환한다.

- 동등 비교 연산자
  - ==, !=
  - 피연산자 비교 전 암묵적 타입 변환으로 타입을 일치시킨 뒤 값을 비교한다.
- 일치 비교 연산자
  - ===, !==

<aside>
💡 Object.is

- Object.is(value1, value2) 메서드를 사용하면 아래와 같은 경우에도 예측 가능한 정확한 결과를 반환한다. - NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 `Number.isNaN`을 사용해 조사한다. - -0과 +0은 동등, 일치 비교 시 모두 `true`를 반환한다.
</aside>

### 쉽표 연산자

쉼표 연산자는 차례대로 피연산자를 평가하고 마지막 피연산자의 평가 결과를 반환한다.

### 그룹 연산자

그룹 연산자는 우선순위가 가장 높아 피연산자를 감싸 우선 순위 조절에 사용된다.

### typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

- null은 object를 반환한다. 따라서 값이 null인지 확 할 때에는 typeof 대신 일치 연산자를 사용한다.
- 선언하지 않은 식별자를 typeof 연산하면 ReferenceError가 아닌 undefined를 반환한다.

[연산자 우선순위 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_precedence#%ED%91%9C)

---

## 8. 제어문

### 블록문

`{}` 중괄호로 0개 이상의 문을 묶은 것으로 코드 블록이라고도 한다. 단독으로 사용할 수 있으나 주로 제어문이나 함수에서 사용.

### 조건문

조건식의 평가 결과에 따라 블록문의 실행을 결정한다.

**if…else 문**

```jsx
if (조건식1) {
  // 조건식1이 참이면 이 블록 실행
} else if (조건식2) {
  // 조건식2가 참이면 이 블록 실행
} else {
  // 조건식1, 2가 모두 거짓이면 이 블록 실행
}
```

조건에 따라 단순히 값을 결정하여 변수에 할당하는 경우 삼항 조건 연산자를 사용하는 편이 가독성이 더 좋다.

**switch 문**

switch문은 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 흐름을 옮긴다.

if…else 문의 조건식은 불리언 값으로 평가되지만, switch 문의 표현식은 문자열이나 숫자 값인 경우가 많다. 때문에 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.

```jsx
switch (표현식) {
  case 표현식1:
    // 문의 표현식과 표현식1이 일치하면 실행될 문
    break;
  case 표현식2:
    // 문의 표현식과 표현식2이 일치하면 실행될 문
    break;
  default:
    // 문의 표현식과 일치하는 case 문이 없을 때 실행될 문
    break;
}
```

switch문은 break를 쓰지 않으면 해당 case의 코드를 실행 한 후 switch문을 탈출하지 않고, 이후 모든 case문과 default 문을 실행한다. 이를 **폴 스루**라고 한다.

### 반복문

반복문은 조건식의 평과 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 평가하여 여전히 참인 경우 코드 블록을 다시 실행한다.

**for문**

```jsx
for (변수 선언문; 조건식; 증감식) {
  // 조건식이 참인 경우 반복 실행될 문
}
```

for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다.

```jsx
for (;;) {} // 무한루프
```

**while 문**

while문은 조건식의 평가 결과가 참이면 코드 블록을 반복해서 실행한다. for 문은 반복 횟수가 명활할 때 주로 사용하고, while 문은 반복 횟수가 불명확할 때 주로 사용한다.

```jsx
while (조건식) {
  // 실행 코드 블럭
}
```

**do…while 문**

do…while문은 코드 블럭을 먼저 한 번 실행하고 조건식을 평가한다. 따라서 무조건 한 번 이상 실행된다.

```jsx
do {
  // 실행 코드 블럭
} while (조건식);
```

### break 문

반복문, 레이블 문, switch 문의 코드 블록을 탈출한다. 그 외의 코드 블록에서 break를 사용하면 SyntaxError가 발생한다.

**레이블 문**

식별자가 붙은 문으로 실행 순서를 제어할 때 사용한다.

```jsx
labelName: for() {}
```

반복문 외부로 탈출할 때 유용하나 그 밖에 경우 가독성이 나빠져 사용하지 않는 것을 권장한다.

### continue 문

continue 문은 코드 블록 실행을 현 지점에서 중단하고 반복문의 처음으로 돌아가 다음 코드를 실행한다.

---

## 9. 타입 변환과 단축 평가

### 타입 변환

- **명시적 타입 변환** or **타입 캐스팅**: 개발자가 의도적으로 값의 타입을 변환하는 것
- **암묵적 타입 변환** or **타입 강제 변환**: 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환 되는 것

타입 변환은 기존 값을 직접 변경하는 게 아닌 다른 타입의 **새로운 원시 값을 생성**하는 것이다.

명시적 타입 변환은 개발자의 의도를 보여주기 때문에 코드가 예측 가능 해지고 오류를 줄일 수 있다. 하지만 암묵적 타입 변환이 가독성에 좋은 경우가 있어 적절히 사용하자!

중요한 것은 **예측 가능한 코드**와 **쉽게 이해할 수 있어야** 한다.

### 암묵적 타입 변환

- 문자열 타입으로 변환
  - ES6에서 도입된 템플릿 리터럴은 `${}`내부의 표현식을 암묵적으로 문자열로 변환한다.
  - `+ ‘’` 빈 문자열을 더해 암묵적으로 문자열 타입으로 변환할 수 있다.
- 숫자 타입으로 변환
  - - 단항 연산자를 피연산자의 앞에 붙여 숫자 타입으로 변환한다.
      객체, 비어있지 않은 배열, undefined, 함수는 NaN을 반환한다.
- 불리언 타입으로 변환
  - if나 for 문과 같은 조건식의 평가 결과를 불리언 타입으로 변환한다. !
    falsy 값: false, undefined, null, 0, -0, NaN, ‘’. 그 외의 값은 truthy

### 명시적 타입 변환

- 문자열 타입으로 변환
  - `String()`, `toString()`
- 숫자 타입으로 변환
  - `Number()`, `parseInt()`
- 불리언 타입으로 변환
  - `Boolean()`

### 단축 평가

논리 연산의 **결과를 결정하는 피연산자**를 타입 변환하지 않고 그대로 반환하는 것.

```jsx
'Cat' && 'Dog';
```

위 코드에서 논리 곱 연산자는 첫 번째 피연산자가 true라면 두 번째 피연산자에 의해 결과를 결정한다. 따라서 Dog를 반환한다.

`||`(논리 합) 연산자라면 첫 번째 피연산자가 true로 결과가 결정나기 때문에 Cat을 반환한다.

**옵셔널 체이닝 (?.)**

ES(11)에서 도입된 연산자로 좌항의 연산자가 null이나 undefined인 경우 undefined를 반환하고, 아니라면 우항의 프로퍼티 참조를 이어간다.

```jsx
const object1 = null;
const object2 = { key: value };

object1 && object.key; // null
object1?.key; // undefined
object2?.key; // value
```

**null 병합 연산자**

`||`논리 합 연산자와 비슷하지만 `??`는 falsy한 값이라도 **null**과 **undefined**가 아니면 좌항의 피연산자를 반환한다.

`??`는 `||`, `&&`와 함께 사용할 때 괄호로 명시적으로 우선순위를 지정하지 않으면 에러가 발생한다.
